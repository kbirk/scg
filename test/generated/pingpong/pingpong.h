

// Code generated by scg. DO NOT EDIT.
//
// Version: 0.0.1
//
// Source: pingpong.scg
//
// SHA: 35e4b47b4c5907add4198757648b3615a4e5b0ccbca0c097ac60201915a4e679
//
// Date: 2024-06-08T14:58:32-04:00

#pragma once

#include <scg/serialize.h>
#include <nlohmann/json.hpp>
#include <scg/client.h>

namespace pingpong { 

struct Ping {
	int32_t count;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"count", count } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("count").get_to(count);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(count);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, count);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(count, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, count);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(count, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(count);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Ping, count)

struct PingRequest {
	Ping ping;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"ping", ping } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("ping").get_to(ping);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(ping);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, ping);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(ping, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, ping);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(ping, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(ping);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(PingRequest, ping)

struct Pong {
	int32_t count;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"count", count } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("count").get_to(count);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(count);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, count);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(count, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, count);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(count, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(count);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Pong, count)

struct PongResponse {
	Pong pong;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"pong", pong } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("pong").get_to(pong);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(pong);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, pong);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(pong, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, pong);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(pong, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(pong);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(PongResponse, pong)

static constexpr uint64_t pingPongID = 8327373094710716227UL;
static constexpr uint64_t ping_PingID = 16843147157235268489UL;

class PingPongClient {
public:
	inline explicit
	PingPongClient(std::shared_ptr<scg::rpc::Client> client) : client_(client) {}
	
	inline std::pair<PongResponse, scg::error::Error> ping(const scg::context::Context& ctx, const PingRequest& req) const
	{
		std::pair<PongResponse, scg::error::Error> res;

		auto [reader, err] = client_->call(ctx, pingPongID, ping_PingID, req);
		if (err) {
			res.second = err;
			return res;
		}

		err = res.first.deserialize(reader);
		if (err) {
			res.second = err;
			return res;
		}

		return res;
	}

	inline scg::error::Error ping(PongResponse* resp, const scg::context::Context& ctx, const PingRequest& req) const
	{
		auto [reader, err] = client_->call(ctx, pingPongID, ping_PingID, req);
		if (err) {
			return err;
		}

		return resp->deserialize(reader);
	}
	

private:
	std::shared_ptr<scg::rpc::Client> client_;
};

} 
