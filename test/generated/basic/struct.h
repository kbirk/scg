

// Code generated by scg. DO NOT EDIT.
//
// Version: 0.0.1
//
// Source: struct.scg
//
// SHA: ab5a13c72249e4561d0c95b2539d0ffd193d4f318fa882a9aef1ce8b91d4d9f8
//
// Date: 2024-06-08T14:58:32-04:00

#pragma once

#include <scg/serialize.h>
#include <nlohmann/json.hpp>

namespace basic { 

struct BasicStruct {
	uint8_t valUint8;
	int8_t valInt8;
	uint16_t valUint16;
	int16_t valInt16;
	uint32_t valUint32;
	int32_t valInt32;
	uint64_t valUint64;
	int64_t valInt64;
	std::string valString;
	std::vector<std::string> valArrayString;
	std::map<std::string, float32_t> valMapStringFloat32;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"valUint8", valUint8 }, 
			{"valInt8", valInt8 }, 
			{"valUint16", valUint16 }, 
			{"valInt16", valInt16 }, 
			{"valUint32", valUint32 }, 
			{"valInt32", valInt32 }, 
			{"valUint64", valUint64 }, 
			{"valInt64", valInt64 }, 
			{"valString", valString }, 
			{"valArrayString", valArrayString }, 
			{"valMapStringFloat32", valMapStringFloat32 } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("valUint8").get_to(valUint8);
		j.at("valInt8").get_to(valInt8);
		j.at("valUint16").get_to(valUint16);
		j.at("valInt16").get_to(valInt16);
		j.at("valUint32").get_to(valUint32);
		j.at("valInt32").get_to(valInt32);
		j.at("valUint64").get_to(valUint64);
		j.at("valInt64").get_to(valInt64);
		j.at("valString").get_to(valString);
		j.at("valArrayString").get_to(valArrayString);
		j.at("valMapStringFloat32").get_to(valMapStringFloat32);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(valUint8);
		size += scg::serialize::calc_byte_size(valInt8);
		size += scg::serialize::calc_byte_size(valUint16);
		size += scg::serialize::calc_byte_size(valInt16);
		size += scg::serialize::calc_byte_size(valUint32);
		size += scg::serialize::calc_byte_size(valInt32);
		size += scg::serialize::calc_byte_size(valUint64);
		size += scg::serialize::calc_byte_size(valInt64);
		size += scg::serialize::calc_byte_size(valString);
		size += scg::serialize::calc_byte_size(valArrayString);
		size += scg::serialize::calc_byte_size(valMapStringFloat32);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, valUint8);
		scg::serialize::serialize(writer, valInt8);
		scg::serialize::serialize(writer, valUint16);
		scg::serialize::serialize(writer, valInt16);
		scg::serialize::serialize(writer, valUint32);
		scg::serialize::serialize(writer, valInt32);
		scg::serialize::serialize(writer, valUint64);
		scg::serialize::serialize(writer, valInt64);
		scg::serialize::serialize(writer, valString);
		scg::serialize::serialize(writer, valArrayString);
		scg::serialize::serialize(writer, valMapStringFloat32);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(valUint8, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valInt8, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valUint16, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valInt16, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valUint32, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valInt32, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valUint64, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valInt64, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valString, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valArrayString, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valMapStringFloat32, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, valUint8);scg::serialize::serialize(writer, valInt8);scg::serialize::serialize(writer, valUint16);scg::serialize::serialize(writer, valInt16);scg::serialize::serialize(writer, valUint32);scg::serialize::serialize(writer, valInt32);scg::serialize::serialize(writer, valUint64);scg::serialize::serialize(writer, valInt64);scg::serialize::serialize(writer, valString);scg::serialize::serialize(writer, valArrayString);scg::serialize::serialize(writer, valMapStringFloat32);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(valUint8, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valInt8, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valUint16, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valInt16, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valUint32, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valInt32, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valUint64, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valInt64, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valString, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valArrayString, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valMapStringFloat32, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(valUint8);
		size += scg::serialize::calc_byte_size(valInt8);
		size += scg::serialize::calc_byte_size(valUint16);
		size += scg::serialize::calc_byte_size(valInt16);
		size += scg::serialize::calc_byte_size(valUint32);
		size += scg::serialize::calc_byte_size(valInt32);
		size += scg::serialize::calc_byte_size(valUint64);
		size += scg::serialize::calc_byte_size(valInt64);
		size += scg::serialize::calc_byte_size(valString);
		size += scg::serialize::calc_byte_size(valArrayString);
		size += scg::serialize::calc_byte_size(valMapStringFloat32);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(BasicStruct, valUint8, valInt8, valUint16, valInt16, valUint32, valInt32, valUint64, valInt64, valString, valArrayString, valMapStringFloat32)

struct ComplicatedStruct {
	std::map<std::string, StructA> structAMap;
	std::vector<StructB> structBArray;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"structAMap", structAMap }, 
			{"structBArray", structBArray } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("structAMap").get_to(structAMap);
		j.at("structBArray").get_to(structBArray);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(structAMap);
		size += scg::serialize::calc_byte_size(structBArray);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, structAMap);
		scg::serialize::serialize(writer, structBArray);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(structAMap, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(structBArray, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, structAMap);scg::serialize::serialize(writer, structBArray);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(structAMap, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(structBArray, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(structAMap);
		size += scg::serialize::calc_byte_size(structBArray);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(ComplicatedStruct, structAMap, structBArray)

struct StructA {
	int8_t valInt8;
	float32_t valFloat32;
	bool valBool;
	std::map<uint8_t, std::string> valMapUint8String;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"valInt8", valInt8 }, 
			{"valFloat32", valFloat32 }, 
			{"valBool", valBool }, 
			{"valMapUint8String", valMapUint8String } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("valInt8").get_to(valInt8);
		j.at("valFloat32").get_to(valFloat32);
		j.at("valBool").get_to(valBool);
		j.at("valMapUint8String").get_to(valMapUint8String);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(valInt8);
		size += scg::serialize::calc_byte_size(valFloat32);
		size += scg::serialize::calc_byte_size(valBool);
		size += scg::serialize::calc_byte_size(valMapUint8String);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, valInt8);
		scg::serialize::serialize(writer, valFloat32);
		scg::serialize::serialize(writer, valBool);
		scg::serialize::serialize(writer, valMapUint8String);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(valInt8, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valFloat32, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valBool, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valMapUint8String, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, valInt8);scg::serialize::serialize(writer, valFloat32);scg::serialize::serialize(writer, valBool);scg::serialize::serialize(writer, valMapUint8String);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(valInt8, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valFloat32, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valBool, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valMapUint8String, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(valInt8);
		size += scg::serialize::calc_byte_size(valFloat32);
		size += scg::serialize::calc_byte_size(valBool);
		size += scg::serialize::calc_byte_size(valMapUint8String);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(StructA, valInt8, valFloat32, valBool, valMapUint8String)

struct StructB {
	std::vector<int32_t> valArrayInt;
	std::map<std::string, int32_t> valMapStringInt;
	std::map<int8_t, std::map<int16_t, std::string>> valMapUint8MapUint16String;

	inline std::vector<uint8_t> toJSON() const
	{
		nlohmann::json j({
			{"valArrayInt", valArrayInt }, 
			{"valMapStringInt", valMapStringInt }, 
			{"valMapUint8MapUint16String", valMapUint8MapUint16String } });
		auto str = j.dump();
		return std::vector<uint8_t>(str.begin(), str.end());
	}

	inline void fromJSON(const std::vector<uint8_t>& data)
	{
		nlohmann::json j = nlohmann::json::parse(std::string(data.begin(), data.end()));
		j.at("valArrayInt").get_to(valArrayInt);
		j.at("valMapStringInt").get_to(valMapStringInt);
		j.at("valMapUint8MapUint16String").get_to(valMapUint8MapUint16String);
		
	}

	inline std::vector<uint8_t> toBytes() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(valArrayInt);
		size += scg::serialize::calc_byte_size(valMapStringInt);
		size += scg::serialize::calc_byte_size(valMapUint8MapUint16String);

		scg::serialize::FixedSizeWriter writer(size);
		scg::serialize::serialize(writer, valArrayInt);
		scg::serialize::serialize(writer, valMapStringInt);
		scg::serialize::serialize(writer, valMapUint8MapUint16String);
		return writer.bytes();
	}

	inline scg::error::Error fromBytes(const std::vector<uint8_t>& data)
	{
		scg::error::Error err;
		scg::serialize::Reader reader(data);
		err = scg::serialize::deserialize(valArrayInt, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valMapStringInt, reader);
		if (err) {
			return err;
		}
		
		err = scg::serialize::deserialize(valMapUint8MapUint16String, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline void serialize(scg::serialize::FixedSizeWriter& writer) const
	{
		scg::serialize::serialize(writer, valArrayInt);scg::serialize::serialize(writer, valMapStringInt);scg::serialize::serialize(writer, valMapUint8MapUint16String);
	}

	inline scg::error::Error deserialize(scg::serialize::Reader& reader)
	{
		scg::error::Error err;
		err = scg::serialize::deserialize(valArrayInt, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valMapStringInt, reader);
		if (err) {
			return err;
		}
		err = scg::serialize::deserialize(valMapUint8MapUint16String, reader);
		if (err) {
			return err;
		}
		
		return nullptr;
	}

	inline uint32_t byteSize() const
	{
		uint32_t size = 0;
		size += scg::serialize::calc_byte_size(valArrayInt);
		size += scg::serialize::calc_byte_size(valMapStringInt);
		size += scg::serialize::calc_byte_size(valMapUint8MapUint16String);
		return size;
	}

};
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(StructB, valArrayInt, valMapStringInt, valMapUint8MapUint16String)

} 
