// Code generated by scg. DO NOT EDIT.
//
// Version: 0.0.1
//
// Source: benchmark.scg
//
// SHA: b98512b0e6af5cb4665db3aa098022b0c309ba94730fc80eb1cb296e807ca79d

package benchmark

import (
	"context"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"time"

	"github.com/kbirk/scg/pkg/rpc"
	"github.com/kbirk/scg/pkg/serialize"
)

type ProcessStatus uint16

func (p *ProcessStatus) BitSize() int {
	return serialize.BitSizeUInt16(*(*uint16)(p))
}

func (p *ProcessStatus) Serialize(writer *serialize.Writer) {
	serialize.SerializeUInt16(writer, *(*uint16)(p))
}

func (p *ProcessStatus) Deserialize(reader *serialize.Reader) error {
	return serialize.DeserializeUInt16((*uint16)(p), reader)
}

func (p ProcessStatus) Value() (driver.Value, error) {
	return ProcessStatus_ToString[p], nil
}

func (p *ProcessStatus) Scan(src interface{}) error {
	switch src := src.(type) {
	case string:
		*p = ProcessStatusString_ToEnum[src]
		return nil
	case []byte:
		*p = ProcessStatusString_ToEnum[string(src)]
		return nil
	case nil:
		var def ProcessStatus
		*p = def
		return nil
	default:
		return fmt.Errorf("cannot scan type %T into type ProcessStatus", src)
	}
}

const (
	ProcessStatus_Pending        ProcessStatus = 0
	ProcessStatus_Success        ProcessStatus = 1
	ProcessStatus_Failed         ProcessStatus = 2
	ProcessStatus_Partial        ProcessStatus = 3
	ProcessStatus_Pending_String               = "PENDING"
	ProcessStatus_Success_String               = "SUCCESS"
	ProcessStatus_Failed_String                = "FAILED"
	ProcessStatus_Partial_String               = "PARTIAL"
)

var (
	ProcessStatus_ToString = map[ProcessStatus]string{
		ProcessStatus_Pending: ProcessStatus_Pending_String,
		ProcessStatus_Success: ProcessStatus_Success_String,
		ProcessStatus_Failed:  ProcessStatus_Failed_String,
		ProcessStatus_Partial: ProcessStatus_Partial_String,
	}
	ProcessStatusString_ToEnum = map[string]ProcessStatus{
		ProcessStatus_Pending_String: ProcessStatus_Pending,
		ProcessStatus_Success_String: ProcessStatus_Success,
		ProcessStatus_Failed_String:  ProcessStatus_Failed,
		ProcessStatus_Partial_String: ProcessStatus_Partial,
	}
)

type UserRole uint16

func (u *UserRole) BitSize() int {
	return serialize.BitSizeUInt16(*(*uint16)(u))
}

func (u *UserRole) Serialize(writer *serialize.Writer) {
	serialize.SerializeUInt16(writer, *(*uint16)(u))
}

func (u *UserRole) Deserialize(reader *serialize.Reader) error {
	return serialize.DeserializeUInt16((*uint16)(u), reader)
}

func (u UserRole) Value() (driver.Value, error) {
	return UserRole_ToString[u], nil
}

func (u *UserRole) Scan(src interface{}) error {
	switch src := src.(type) {
	case string:
		*u = UserRoleString_ToEnum[src]
		return nil
	case []byte:
		*u = UserRoleString_ToEnum[string(src)]
		return nil
	case nil:
		var def UserRole
		*u = def
		return nil
	default:
		return fmt.Errorf("cannot scan type %T into type UserRole", src)
	}
}

const (
	UserRole_Guest             UserRole = 0
	UserRole_User              UserRole = 1
	UserRole_Admin             UserRole = 2
	UserRole_SuperAdmin        UserRole = 3
	UserRole_Guest_String               = "GUEST"
	UserRole_User_String                = "USER"
	UserRole_Admin_String               = "ADMIN"
	UserRole_SuperAdmin_String          = "SUPER_ADMIN"
)

var (
	UserRole_ToString = map[UserRole]string{
		UserRole_Guest:      UserRole_Guest_String,
		UserRole_User:       UserRole_User_String,
		UserRole_Admin:      UserRole_Admin_String,
		UserRole_SuperAdmin: UserRole_SuperAdmin_String,
	}
	UserRoleString_ToEnum = map[string]UserRole{
		UserRole_Guest_String:      UserRole_Guest,
		UserRole_User_String:       UserRole_User,
		UserRole_Admin_String:      UserRole_Admin,
		UserRole_SuperAdmin_String: UserRole_SuperAdmin,
	}
)

type EchoRequest struct {
	Message   string `json:"message"`
	Timestamp uint64 `json:"timestamp"`
}

func (e *EchoRequest) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(e)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (e *EchoRequest) FromJSON(data []byte) error {
	err := json.Unmarshal(data, e)
	if err != nil {
		return err
	}
	return nil
}
func (e *EchoRequest) ToBytes() []byte {
	size := e.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	e.Serialize(writer)
	return writer.Bytes()
}

func (e *EchoRequest) FromBytes(bs []byte) error {
	return e.Deserialize(serialize.NewReader(bs))
}

func (e *EchoRequest) BitSize() int {
	size := 0
	size += serialize.BitSizeString(e.Message)
	size += serialize.BitSizeUInt64(e.Timestamp)
	return size
}

func (e *EchoRequest) Serialize(writer *serialize.Writer) {
	serialize.SerializeString(writer, e.Message)
	serialize.SerializeUInt64(writer, e.Timestamp)
}

func (e *EchoRequest) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeString(&e.Message, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeUInt64(&e.Timestamp, reader)
	if err != nil {
		return err
	}
	return nil
}

type EchoResponse struct {
	Message         string `json:"message"`
	Timestamp       uint64 `json:"timestamp"`
	ServerTimestamp uint64 `json:"server_timestamp"`
}

func (e *EchoResponse) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(e)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (e *EchoResponse) FromJSON(data []byte) error {
	err := json.Unmarshal(data, e)
	if err != nil {
		return err
	}
	return nil
}
func (e *EchoResponse) ToBytes() []byte {
	size := e.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	e.Serialize(writer)
	return writer.Bytes()
}

func (e *EchoResponse) FromBytes(bs []byte) error {
	return e.Deserialize(serialize.NewReader(bs))
}

func (e *EchoResponse) BitSize() int {
	size := 0
	size += serialize.BitSizeString(e.Message)
	size += serialize.BitSizeUInt64(e.Timestamp)
	size += serialize.BitSizeUInt64(e.ServerTimestamp)
	return size
}

func (e *EchoResponse) Serialize(writer *serialize.Writer) {
	serialize.SerializeString(writer, e.Message)
	serialize.SerializeUInt64(writer, e.Timestamp)
	serialize.SerializeUInt64(writer, e.ServerTimestamp)
}

func (e *EchoResponse) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeString(&e.Message, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeUInt64(&e.Timestamp, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeUInt64(&e.ServerTimestamp, reader)
	if err != nil {
		return err
	}
	return nil
}

type LargePayloadRequest struct {
	RequestID  uuid.UUID              `json:"request_id"`
	CreatedAt  time.Time              `json:"created_at"`
	BinaryData []uint8                `json:"binary_data"`
	Tags       []string               `json:"tags"`
	Metrics    map[string]MetricValue `json:"metrics"`
}

func (l *LargePayloadRequest) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(l)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (l *LargePayloadRequest) FromJSON(data []byte) error {
	err := json.Unmarshal(data, l)
	if err != nil {
		return err
	}
	return nil
}
func (l *LargePayloadRequest) ToBytes() []byte {
	size := l.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	l.Serialize(writer)
	return writer.Bytes()
}

func (l *LargePayloadRequest) FromBytes(bs []byte) error {
	return l.Deserialize(serialize.NewReader(bs))
}

func largePayloadRequest_BitSizeListString(arg []string) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for _, v := range arg {
		size += serialize.BitSizeString(v)
	}
	return size
}

func largePayloadRequest_BitSizeListUInt8(arg []uint8) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for _, v := range arg {
		size += serialize.BitSizeUInt8(v)
	}
	return size
}

func largePayloadRequest_BitSizeMapStringMetricValue(arg map[string]MetricValue) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for k, v := range arg {
		size += serialize.BitSizeString(k) + v.BitSize()
	}
	return size
}

func (l *LargePayloadRequest) BitSize() int {
	size := 0
	size += serialize.BitSizeUUID(l.RequestID)
	size += serialize.BitSizeTime(l.CreatedAt)
	size += largePayloadRequest_BitSizeListUInt8(l.BinaryData)
	size += largePayloadRequest_BitSizeListString(l.Tags)
	size += largePayloadRequest_BitSizeMapStringMetricValue(l.Metrics)
	return size
}

func largePayloadRequest_SerializeListString(writer *serialize.Writer, arg []string) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for _, v := range arg {
		serialize.SerializeString(writer, v)
	}
	return nil
}

func largePayloadRequest_SerializeListUInt8(writer *serialize.Writer, arg []uint8) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for _, v := range arg {
		serialize.SerializeUInt8(writer, v)
	}
	return nil
}

func largePayloadRequest_SerializeMapStringMetricValue(writer *serialize.Writer, arg map[string]MetricValue) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for k, v := range arg {
		serialize.SerializeString(writer, k)
		v.Serialize(writer)
	}
	return nil
}

func (l *LargePayloadRequest) Serialize(writer *serialize.Writer) {
	serialize.SerializeUUID(writer, l.RequestID)
	serialize.SerializeTime(writer, l.CreatedAt)
	largePayloadRequest_SerializeListUInt8(writer, l.BinaryData)
	largePayloadRequest_SerializeListString(writer, l.Tags)
	largePayloadRequest_SerializeMapStringMetricValue(writer, l.Metrics)
}

func largePayloadRequest_DeserializeListString(arg *[]string, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make([]string, int(length))

	for i := 0; i < int(length); i++ {
		var v string
		err := serialize.DeserializeString(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[i] = v
	}
	return nil
}

func largePayloadRequest_DeserializeListUInt8(arg *[]uint8, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make([]uint8, int(length))

	for i := 0; i < int(length); i++ {
		var v uint8
		err := serialize.DeserializeUInt8(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[i] = v
	}
	return nil
}

func largePayloadRequest_DeserializeMapStringMetricValue(arg *map[string]MetricValue, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make(map[string]MetricValue, int(length))

	for i := 0; i < int(length); i++ {
		var k string
		var v MetricValue
		err := serialize.DeserializeString(&k, reader)
		if err != nil {
			return err
		}
		err = v.Deserialize(reader)
		if err != nil {
			return err
		}
		(*arg)[k] = v
	}
	return nil
}

func (l *LargePayloadRequest) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeUUID(&l.RequestID, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeTime(&l.CreatedAt, reader)
	if err != nil {
		return err
	}
	err = largePayloadRequest_DeserializeListUInt8(&l.BinaryData, reader)
	if err != nil {
		return err
	}
	err = largePayloadRequest_DeserializeListString(&l.Tags, reader)
	if err != nil {
		return err
	}
	err = largePayloadRequest_DeserializeMapStringMetricValue(&l.Metrics, reader)
	if err != nil {
		return err
	}
	return nil
}

type LargePayloadResponse struct {
	RequestID     uuid.UUID              `json:"request_id"`
	ProcessedAt   time.Time              `json:"processed_at"`
	ProcessedData []uint8                `json:"processed_data"`
	Results       map[string]MetricValue `json:"results"`
}

func (l *LargePayloadResponse) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(l)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (l *LargePayloadResponse) FromJSON(data []byte) error {
	err := json.Unmarshal(data, l)
	if err != nil {
		return err
	}
	return nil
}
func (l *LargePayloadResponse) ToBytes() []byte {
	size := l.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	l.Serialize(writer)
	return writer.Bytes()
}

func (l *LargePayloadResponse) FromBytes(bs []byte) error {
	return l.Deserialize(serialize.NewReader(bs))
}

func largePayloadResponse_BitSizeListUInt8(arg []uint8) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for _, v := range arg {
		size += serialize.BitSizeUInt8(v)
	}
	return size
}

func largePayloadResponse_BitSizeMapStringMetricValue(arg map[string]MetricValue) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for k, v := range arg {
		size += serialize.BitSizeString(k) + v.BitSize()
	}
	return size
}

func (l *LargePayloadResponse) BitSize() int {
	size := 0
	size += serialize.BitSizeUUID(l.RequestID)
	size += serialize.BitSizeTime(l.ProcessedAt)
	size += largePayloadResponse_BitSizeListUInt8(l.ProcessedData)
	size += largePayloadResponse_BitSizeMapStringMetricValue(l.Results)
	return size
}

func largePayloadResponse_SerializeListUInt8(writer *serialize.Writer, arg []uint8) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for _, v := range arg {
		serialize.SerializeUInt8(writer, v)
	}
	return nil
}

func largePayloadResponse_SerializeMapStringMetricValue(writer *serialize.Writer, arg map[string]MetricValue) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for k, v := range arg {
		serialize.SerializeString(writer, k)
		v.Serialize(writer)
	}
	return nil
}

func (l *LargePayloadResponse) Serialize(writer *serialize.Writer) {
	serialize.SerializeUUID(writer, l.RequestID)
	serialize.SerializeTime(writer, l.ProcessedAt)
	largePayloadResponse_SerializeListUInt8(writer, l.ProcessedData)
	largePayloadResponse_SerializeMapStringMetricValue(writer, l.Results)
}

func largePayloadResponse_DeserializeListUInt8(arg *[]uint8, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make([]uint8, int(length))

	for i := 0; i < int(length); i++ {
		var v uint8
		err := serialize.DeserializeUInt8(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[i] = v
	}
	return nil
}

func largePayloadResponse_DeserializeMapStringMetricValue(arg *map[string]MetricValue, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make(map[string]MetricValue, int(length))

	for i := 0; i < int(length); i++ {
		var k string
		var v MetricValue
		err := serialize.DeserializeString(&k, reader)
		if err != nil {
			return err
		}
		err = v.Deserialize(reader)
		if err != nil {
			return err
		}
		(*arg)[k] = v
	}
	return nil
}

func (l *LargePayloadResponse) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeUUID(&l.RequestID, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeTime(&l.ProcessedAt, reader)
	if err != nil {
		return err
	}
	err = largePayloadResponse_DeserializeListUInt8(&l.ProcessedData, reader)
	if err != nil {
		return err
	}
	err = largePayloadResponse_DeserializeMapStringMetricValue(&l.Results, reader)
	if err != nil {
		return err
	}
	return nil
}

type Level1 struct {
	Name   string `json:"name"`
	Level2 Level2 `json:"level2"`
}

func (l *Level1) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(l)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (l *Level1) FromJSON(data []byte) error {
	err := json.Unmarshal(data, l)
	if err != nil {
		return err
	}
	return nil
}
func (l *Level1) ToBytes() []byte {
	size := l.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	l.Serialize(writer)
	return writer.Bytes()
}

func (l *Level1) FromBytes(bs []byte) error {
	return l.Deserialize(serialize.NewReader(bs))
}

func (l *Level1) BitSize() int {
	size := 0
	size += serialize.BitSizeString(l.Name)
	size += l.Level2.BitSize()
	return size
}

func (l *Level1) Serialize(writer *serialize.Writer) {
	serialize.SerializeString(writer, l.Name)
	l.Level2.Serialize(writer)
}

func (l *Level1) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeString(&l.Name, reader)
	if err != nil {
		return err
	}
	err = l.Level2.Deserialize(reader)
	if err != nil {
		return err
	}
	return nil
}

type Level2 struct {
	Name   string `json:"name"`
	Level3 Level3 `json:"level3"`
}

func (l *Level2) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(l)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (l *Level2) FromJSON(data []byte) error {
	err := json.Unmarshal(data, l)
	if err != nil {
		return err
	}
	return nil
}
func (l *Level2) ToBytes() []byte {
	size := l.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	l.Serialize(writer)
	return writer.Bytes()
}

func (l *Level2) FromBytes(bs []byte) error {
	return l.Deserialize(serialize.NewReader(bs))
}

func (l *Level2) BitSize() int {
	size := 0
	size += serialize.BitSizeString(l.Name)
	size += l.Level3.BitSize()
	return size
}

func (l *Level2) Serialize(writer *serialize.Writer) {
	serialize.SerializeString(writer, l.Name)
	l.Level3.Serialize(writer)
}

func (l *Level2) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeString(&l.Name, reader)
	if err != nil {
		return err
	}
	err = l.Level3.Deserialize(reader)
	if err != nil {
		return err
	}
	return nil
}

type Level3 struct {
	Name   string           `json:"name"`
	Values []string         `json:"values"`
	Counts map[string]int32 `json:"counts"`
}

func (l *Level3) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(l)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (l *Level3) FromJSON(data []byte) error {
	err := json.Unmarshal(data, l)
	if err != nil {
		return err
	}
	return nil
}
func (l *Level3) ToBytes() []byte {
	size := l.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	l.Serialize(writer)
	return writer.Bytes()
}

func (l *Level3) FromBytes(bs []byte) error {
	return l.Deserialize(serialize.NewReader(bs))
}

func level3_BitSizeListString(arg []string) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for _, v := range arg {
		size += serialize.BitSizeString(v)
	}
	return size
}

func level3_BitSizeMapStringInt32(arg map[string]int32) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for k, v := range arg {
		size += serialize.BitSizeString(k) + serialize.BitSizeInt32(v)
	}
	return size
}

func (l *Level3) BitSize() int {
	size := 0
	size += serialize.BitSizeString(l.Name)
	size += level3_BitSizeListString(l.Values)
	size += level3_BitSizeMapStringInt32(l.Counts)
	return size
}

func level3_SerializeListString(writer *serialize.Writer, arg []string) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for _, v := range arg {
		serialize.SerializeString(writer, v)
	}
	return nil
}

func level3_SerializeMapStringInt32(writer *serialize.Writer, arg map[string]int32) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for k, v := range arg {
		serialize.SerializeString(writer, k)
		serialize.SerializeInt32(writer, v)
	}
	return nil
}

func (l *Level3) Serialize(writer *serialize.Writer) {
	serialize.SerializeString(writer, l.Name)
	level3_SerializeListString(writer, l.Values)
	level3_SerializeMapStringInt32(writer, l.Counts)
}

func level3_DeserializeListString(arg *[]string, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make([]string, int(length))

	for i := 0; i < int(length); i++ {
		var v string
		err := serialize.DeserializeString(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[i] = v
	}
	return nil
}

func level3_DeserializeMapStringInt32(arg *map[string]int32, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make(map[string]int32, int(length))

	for i := 0; i < int(length); i++ {
		var k string
		var v int32
		err := serialize.DeserializeString(&k, reader)
		if err != nil {
			return err
		}
		err = serialize.DeserializeInt32(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[k] = v
	}
	return nil
}

func (l *Level3) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeString(&l.Name, reader)
	if err != nil {
		return err
	}
	err = level3_DeserializeListString(&l.Values, reader)
	if err != nil {
		return err
	}
	err = level3_DeserializeMapStringInt32(&l.Counts, reader)
	if err != nil {
		return err
	}
	return nil
}

type MetricValue struct {
	Value     float64           `json:"value"`
	Timestamp time.Time         `json:"timestamp"`
	Unit      string            `json:"unit"`
	Labels    map[string]string `json:"labels"`
}

func (m *MetricValue) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (m *MetricValue) FromJSON(data []byte) error {
	err := json.Unmarshal(data, m)
	if err != nil {
		return err
	}
	return nil
}
func (m *MetricValue) ToBytes() []byte {
	size := m.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	m.Serialize(writer)
	return writer.Bytes()
}

func (m *MetricValue) FromBytes(bs []byte) error {
	return m.Deserialize(serialize.NewReader(bs))
}

func metricValue_BitSizeMapStringString(arg map[string]string) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for k, v := range arg {
		size += serialize.BitSizeString(k) + serialize.BitSizeString(v)
	}
	return size
}

func (m *MetricValue) BitSize() int {
	size := 0
	size += serialize.BitSizeFloat64(m.Value)
	size += serialize.BitSizeTime(m.Timestamp)
	size += serialize.BitSizeString(m.Unit)
	size += metricValue_BitSizeMapStringString(m.Labels)
	return size
}

func metricValue_SerializeMapStringString(writer *serialize.Writer, arg map[string]string) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for k, v := range arg {
		serialize.SerializeString(writer, k)
		serialize.SerializeString(writer, v)
	}
	return nil
}

func (m *MetricValue) Serialize(writer *serialize.Writer) {
	serialize.SerializeFloat64(writer, m.Value)
	serialize.SerializeTime(writer, m.Timestamp)
	serialize.SerializeString(writer, m.Unit)
	metricValue_SerializeMapStringString(writer, m.Labels)
}

func metricValue_DeserializeMapStringString(arg *map[string]string, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make(map[string]string, int(length))

	for i := 0; i < int(length); i++ {
		var k string
		var v string
		err := serialize.DeserializeString(&k, reader)
		if err != nil {
			return err
		}
		err = serialize.DeserializeString(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[k] = v
	}
	return nil
}

func (m *MetricValue) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeFloat64(&m.Value, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeTime(&m.Timestamp, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeString(&m.Unit, reader)
	if err != nil {
		return err
	}
	err = metricValue_DeserializeMapStringString(&m.Labels, reader)
	if err != nil {
		return err
	}
	return nil
}

type NestedMessage struct {
	Level1 Level1 `json:"level1"`
}

func (n *NestedMessage) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(n)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (n *NestedMessage) FromJSON(data []byte) error {
	err := json.Unmarshal(data, n)
	if err != nil {
		return err
	}
	return nil
}
func (n *NestedMessage) ToBytes() []byte {
	size := n.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	n.Serialize(writer)
	return writer.Bytes()
}

func (n *NestedMessage) FromBytes(bs []byte) error {
	return n.Deserialize(serialize.NewReader(bs))
}

func (n *NestedMessage) BitSize() int {
	size := 0
	size += n.Level1.BitSize()
	return size
}

func (n *NestedMessage) Serialize(writer *serialize.Writer) {
	n.Level1.Serialize(writer)
}

func (n *NestedMessage) Deserialize(reader *serialize.Reader) error {
	var err error
	err = n.Level1.Deserialize(reader)
	if err != nil {
		return err
	}
	return nil
}

type OrderItem struct {
	ItemID     uuid.UUID         `json:"item_id"`
	Name       string            `json:"name"`
	Quantity   uint32            `json:"quantity"`
	UnitPrice  float64           `json:"unit_price"`
	TotalPrice float64           `json:"total_price"`
	Attributes map[string]string `json:"attributes"`
}

func (o *OrderItem) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (o *OrderItem) FromJSON(data []byte) error {
	err := json.Unmarshal(data, o)
	if err != nil {
		return err
	}
	return nil
}
func (o *OrderItem) ToBytes() []byte {
	size := o.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	o.Serialize(writer)
	return writer.Bytes()
}

func (o *OrderItem) FromBytes(bs []byte) error {
	return o.Deserialize(serialize.NewReader(bs))
}

func orderItem_BitSizeMapStringString(arg map[string]string) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for k, v := range arg {
		size += serialize.BitSizeString(k) + serialize.BitSizeString(v)
	}
	return size
}

func (o *OrderItem) BitSize() int {
	size := 0
	size += serialize.BitSizeUUID(o.ItemID)
	size += serialize.BitSizeString(o.Name)
	size += serialize.BitSizeUInt32(o.Quantity)
	size += serialize.BitSizeFloat64(o.UnitPrice)
	size += serialize.BitSizeFloat64(o.TotalPrice)
	size += orderItem_BitSizeMapStringString(o.Attributes)
	return size
}

func orderItem_SerializeMapStringString(writer *serialize.Writer, arg map[string]string) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for k, v := range arg {
		serialize.SerializeString(writer, k)
		serialize.SerializeString(writer, v)
	}
	return nil
}

func (o *OrderItem) Serialize(writer *serialize.Writer) {
	serialize.SerializeUUID(writer, o.ItemID)
	serialize.SerializeString(writer, o.Name)
	serialize.SerializeUInt32(writer, o.Quantity)
	serialize.SerializeFloat64(writer, o.UnitPrice)
	serialize.SerializeFloat64(writer, o.TotalPrice)
	orderItem_SerializeMapStringString(writer, o.Attributes)
}

func orderItem_DeserializeMapStringString(arg *map[string]string, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make(map[string]string, int(length))

	for i := 0; i < int(length); i++ {
		var k string
		var v string
		err := serialize.DeserializeString(&k, reader)
		if err != nil {
			return err
		}
		err = serialize.DeserializeString(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[k] = v
	}
	return nil
}

func (o *OrderItem) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeUUID(&o.ItemID, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeString(&o.Name, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeUInt32(&o.Quantity, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeFloat64(&o.UnitPrice, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeFloat64(&o.TotalPrice, reader)
	if err != nil {
		return err
	}
	err = orderItem_DeserializeMapStringString(&o.Attributes, reader)
	if err != nil {
		return err
	}
	return nil
}

type ProcessRequest struct {
	ID        string            `json:"id"`
	CreatedAt time.Time         `json:"created_at"`
	User      UserInfo          `json:"user"`
	Items     []OrderItem       `json:"items"`
	Metadata  map[string]string `json:"metadata"`
}

func (p *ProcessRequest) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(p)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (p *ProcessRequest) FromJSON(data []byte) error {
	err := json.Unmarshal(data, p)
	if err != nil {
		return err
	}
	return nil
}
func (p *ProcessRequest) ToBytes() []byte {
	size := p.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	p.Serialize(writer)
	return writer.Bytes()
}

func (p *ProcessRequest) FromBytes(bs []byte) error {
	return p.Deserialize(serialize.NewReader(bs))
}

func processRequest_BitSizeListOrderItem(arg []OrderItem) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for _, v := range arg {
		size += v.BitSize()
	}
	return size
}

func processRequest_BitSizeMapStringString(arg map[string]string) int {
	size := serialize.BitSizeUInt32(uint32(len(arg)))
	for k, v := range arg {
		size += serialize.BitSizeString(k) + serialize.BitSizeString(v)
	}
	return size
}

func (p *ProcessRequest) BitSize() int {
	size := 0
	size += serialize.BitSizeString(p.ID)
	size += serialize.BitSizeTime(p.CreatedAt)
	size += p.User.BitSize()
	size += processRequest_BitSizeListOrderItem(p.Items)
	size += processRequest_BitSizeMapStringString(p.Metadata)
	return size
}

func processRequest_SerializeListOrderItem(writer *serialize.Writer, arg []OrderItem) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for _, v := range arg {
		v.Serialize(writer)
	}
	return nil
}

func processRequest_SerializeMapStringString(writer *serialize.Writer, arg map[string]string) error {
	serialize.SerializeUInt32(writer, uint32(len(arg)))
	for k, v := range arg {
		serialize.SerializeString(writer, k)
		serialize.SerializeString(writer, v)
	}
	return nil
}

func (p *ProcessRequest) Serialize(writer *serialize.Writer) {
	serialize.SerializeString(writer, p.ID)
	serialize.SerializeTime(writer, p.CreatedAt)
	p.User.Serialize(writer)
	processRequest_SerializeListOrderItem(writer, p.Items)
	processRequest_SerializeMapStringString(writer, p.Metadata)
}

func processRequest_DeserializeListOrderItem(arg *[]OrderItem, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make([]OrderItem, int(length))

	for i := 0; i < int(length); i++ {
		var v OrderItem
		err := v.Deserialize(reader)
		if err != nil {
			return err
		}
		(*arg)[i] = v
	}
	return nil
}

func processRequest_DeserializeMapStringString(arg *map[string]string, reader *serialize.Reader) error {
	var length uint32
	err := serialize.DeserializeUInt32(&length, reader)
	if err != nil {
		return err
	}

	*arg = make(map[string]string, int(length))

	for i := 0; i < int(length); i++ {
		var k string
		var v string
		err := serialize.DeserializeString(&k, reader)
		if err != nil {
			return err
		}
		err = serialize.DeserializeString(&v, reader)
		if err != nil {
			return err
		}
		(*arg)[k] = v
	}
	return nil
}

func (p *ProcessRequest) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeString(&p.ID, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeTime(&p.CreatedAt, reader)
	if err != nil {
		return err
	}
	err = p.User.Deserialize(reader)
	if err != nil {
		return err
	}
	err = processRequest_DeserializeListOrderItem(&p.Items, reader)
	if err != nil {
		return err
	}
	err = processRequest_DeserializeMapStringString(&p.Metadata, reader)
	if err != nil {
		return err
	}
	return nil
}

type ProcessResponse struct {
	ID          string          `json:"id"`
	ProcessedAt time.Time       `json:"processed_at"`
	Status      ProcessStatus   `json:"status"`
	Message     string          `json:"message"`
	Stats       ProcessingStats `json:"stats"`
}

func (p *ProcessResponse) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(p)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (p *ProcessResponse) FromJSON(data []byte) error {
	err := json.Unmarshal(data, p)
	if err != nil {
		return err
	}
	return nil
}
func (p *ProcessResponse) ToBytes() []byte {
	size := p.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	p.Serialize(writer)
	return writer.Bytes()
}

func (p *ProcessResponse) FromBytes(bs []byte) error {
	return p.Deserialize(serialize.NewReader(bs))
}

func (p *ProcessResponse) BitSize() int {
	size := 0
	size += serialize.BitSizeString(p.ID)
	size += serialize.BitSizeTime(p.ProcessedAt)
	size += p.Status.BitSize()
	size += serialize.BitSizeString(p.Message)
	size += p.Stats.BitSize()
	return size
}

func (p *ProcessResponse) Serialize(writer *serialize.Writer) {
	serialize.SerializeString(writer, p.ID)
	serialize.SerializeTime(writer, p.ProcessedAt)
	p.Status.Serialize(writer)
	serialize.SerializeString(writer, p.Message)
	p.Stats.Serialize(writer)
}

func (p *ProcessResponse) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeString(&p.ID, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeTime(&p.ProcessedAt, reader)
	if err != nil {
		return err
	}
	err = p.Status.Deserialize(reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeString(&p.Message, reader)
	if err != nil {
		return err
	}
	err = p.Stats.Deserialize(reader)
	if err != nil {
		return err
	}
	return nil
}

type ProcessingStats struct {
	ItemsProcessed   uint32  `json:"items_processed"`
	TotalAmount      float64 `json:"total_amount"`
	ProcessingTimeMs uint64  `json:"processing_time_ms"`
}

func (p *ProcessingStats) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(p)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (p *ProcessingStats) FromJSON(data []byte) error {
	err := json.Unmarshal(data, p)
	if err != nil {
		return err
	}
	return nil
}
func (p *ProcessingStats) ToBytes() []byte {
	size := p.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	p.Serialize(writer)
	return writer.Bytes()
}

func (p *ProcessingStats) FromBytes(bs []byte) error {
	return p.Deserialize(serialize.NewReader(bs))
}

func (p *ProcessingStats) BitSize() int {
	size := 0
	size += serialize.BitSizeUInt32(p.ItemsProcessed)
	size += serialize.BitSizeFloat64(p.TotalAmount)
	size += serialize.BitSizeUInt64(p.ProcessingTimeMs)
	return size
}

func (p *ProcessingStats) Serialize(writer *serialize.Writer) {
	serialize.SerializeUInt32(writer, p.ItemsProcessed)
	serialize.SerializeFloat64(writer, p.TotalAmount)
	serialize.SerializeUInt64(writer, p.ProcessingTimeMs)
}

func (p *ProcessingStats) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeUInt32(&p.ItemsProcessed, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeFloat64(&p.TotalAmount, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeUInt64(&p.ProcessingTimeMs, reader)
	if err != nil {
		return err
	}
	return nil
}

type SmallMessage struct {
	ID    uint64 `json:"id"`
	Value uint32 `json:"value"`
}

func (s *SmallMessage) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (s *SmallMessage) FromJSON(data []byte) error {
	err := json.Unmarshal(data, s)
	if err != nil {
		return err
	}
	return nil
}
func (s *SmallMessage) ToBytes() []byte {
	size := s.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	s.Serialize(writer)
	return writer.Bytes()
}

func (s *SmallMessage) FromBytes(bs []byte) error {
	return s.Deserialize(serialize.NewReader(bs))
}

func (s *SmallMessage) BitSize() int {
	size := 0
	size += serialize.BitSizeUInt64(s.ID)
	size += serialize.BitSizeUInt32(s.Value)
	return size
}

func (s *SmallMessage) Serialize(writer *serialize.Writer) {
	serialize.SerializeUInt64(writer, s.ID)
	serialize.SerializeUInt32(writer, s.Value)
}

func (s *SmallMessage) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeUInt64(&s.ID, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeUInt32(&s.Value, reader)
	if err != nil {
		return err
	}
	return nil
}

type UserInfo struct {
	UserID       uuid.UUID `json:"user_id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	RegisteredAt time.Time `json:"registered_at"`
	Role         UserRole  `json:"role"`
}

func (u *UserInfo) ToJSON() ([]byte, error) {
	jsonData, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	return jsonData, nil
}

func (u *UserInfo) FromJSON(data []byte) error {
	err := json.Unmarshal(data, u)
	if err != nil {
		return err
	}
	return nil
}
func (u *UserInfo) ToBytes() []byte {
	size := u.BitSize()
	writer := serialize.NewWriter(serialize.BitsToBytes(size))
	u.Serialize(writer)
	return writer.Bytes()
}

func (u *UserInfo) FromBytes(bs []byte) error {
	return u.Deserialize(serialize.NewReader(bs))
}

func (u *UserInfo) BitSize() int {
	size := 0
	size += serialize.BitSizeUUID(u.UserID)
	size += serialize.BitSizeString(u.Username)
	size += serialize.BitSizeString(u.Email)
	size += serialize.BitSizeTime(u.RegisteredAt)
	size += u.Role.BitSize()
	return size
}

func (u *UserInfo) Serialize(writer *serialize.Writer) {
	serialize.SerializeUUID(writer, u.UserID)
	serialize.SerializeString(writer, u.Username)
	serialize.SerializeString(writer, u.Email)
	serialize.SerializeTime(writer, u.RegisteredAt)
	u.Role.Serialize(writer)
}

func (u *UserInfo) Deserialize(reader *serialize.Reader) error {
	var err error
	err = serialize.DeserializeUUID(&u.UserID, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeString(&u.Username, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeString(&u.Email, reader)
	if err != nil {
		return err
	}
	err = serialize.DeserializeTime(&u.RegisteredAt, reader)
	if err != nil {
		return err
	}
	err = u.Role.Deserialize(reader)
	if err != nil {
		return err
	}
	return nil
}

const (
	benchmarkServiceServerID         uint64 = 1185139427372986719
	benchmarkServiceServer_EchoID    uint64 = 6525406262299243844
	benchmarkServiceServer_ProcessID uint64 = 2836855729219607290
)

type BenchmarkServiceServer interface {
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)
	Process(context.Context, *ProcessRequest) (*ProcessResponse, error)
}

func RegisterBenchmarkServiceServer(server *rpc.Server, benchmarkServiceServer BenchmarkServiceServer) {
	server.RegisterServer(benchmarkServiceServerID, "BenchmarkService", &benchmarkService_Stub{server, benchmarkServiceServer})
}

type benchmarkService_Stub struct {
	server *rpc.Server
	impl   BenchmarkServiceServer
}

func (s *benchmarkService_Stub) handleEcho(ctx context.Context, middleware []rpc.Middleware, requestID uint64, reader *serialize.Reader) []byte {
	req := &EchoRequest{}
	err := req.Deserialize(reader)
	if err != nil {
		return rpc.RespondWithError(requestID, err)
	}

	handler := func(ctx context.Context, req rpc.Message) (rpc.Message, error) {
		r, ok := req.(*EchoRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type %T", req)
		}
		return s.impl.Echo(ctx, r)
	}

	resp, err := rpc.ApplyHandlerChain(ctx, req, middleware, handler)
	if err != nil {
		return rpc.RespondWithError(requestID, err)
	}

	return rpc.RespondWithMessage(requestID, resp)
}

func (s *benchmarkService_Stub) handleProcess(ctx context.Context, middleware []rpc.Middleware, requestID uint64, reader *serialize.Reader) []byte {
	req := &ProcessRequest{}
	err := req.Deserialize(reader)
	if err != nil {
		return rpc.RespondWithError(requestID, err)
	}

	handler := func(ctx context.Context, req rpc.Message) (rpc.Message, error) {
		r, ok := req.(*ProcessRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type %T", req)
		}
		return s.impl.Process(ctx, r)
	}

	resp, err := rpc.ApplyHandlerChain(ctx, req, middleware, handler)
	if err != nil {
		return rpc.RespondWithError(requestID, err)
	}

	return rpc.RespondWithMessage(requestID, resp)
}

func (s *benchmarkService_Stub) HandleWrapper(ctx context.Context, middleware []rpc.Middleware, requestID uint64, reader *serialize.Reader) []byte {
	var methodID uint64
	err := serialize.DeserializeUInt64(&methodID, reader)
	if err != nil {
		return rpc.RespondWithError(requestID, err)
	}

	switch methodID {
	case benchmarkServiceServer_EchoID:
		return s.handleEcho(ctx, middleware, requestID, reader)
	case benchmarkServiceServer_ProcessID:
		return s.handleProcess(ctx, middleware, requestID, reader)
	default:
		return rpc.RespondWithError(requestID, fmt.Errorf("unrecognized methodID %d", methodID))
	}
}

type BenchmarkServiceClient struct {
	client *rpc.Client
}

func NewBenchmarkServiceClient(client *rpc.Client) *BenchmarkServiceClient {
	return &BenchmarkServiceClient{
		client: client,
	}
}

func (c *BenchmarkServiceClient) Echo(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {

	handler := func(ctx context.Context, req rpc.Message) (rpc.Message, error) {
		reader, err := c.client.Call(ctx, benchmarkServiceServerID, benchmarkServiceServer_EchoID, req)
		if err != nil {
			return nil, err
		}

		resp := &EchoResponse{}
		err = resp.Deserialize(reader)
		if err != nil {
			return nil, err
		}
		return resp, nil
	}

	middleware := c.client.GetMiddleware()
	resp, err := rpc.ApplyHandlerChain(ctx, req, middleware, handler)
	if err != nil {
		return nil, err
	}
	r, ok := resp.(*EchoResponse)
	if !ok {
		return nil, fmt.Errorf("invalid response type %T", resp)
	}
	return r, nil
}

func (c *BenchmarkServiceClient) Process(ctx context.Context, req *ProcessRequest) (*ProcessResponse, error) {

	handler := func(ctx context.Context, req rpc.Message) (rpc.Message, error) {
		reader, err := c.client.Call(ctx, benchmarkServiceServerID, benchmarkServiceServer_ProcessID, req)
		if err != nil {
			return nil, err
		}

		resp := &ProcessResponse{}
		err = resp.Deserialize(reader)
		if err != nil {
			return nil, err
		}
		return resp, nil
	}

	middleware := c.client.GetMiddleware()
	resp, err := rpc.ApplyHandlerChain(ctx, req, middleware, handler)
	if err != nil {
		return nil, err
	}
	r, ok := resp.(*ProcessResponse)
	if !ok {
		return nil, fmt.Errorf("invalid response type %T", resp)
	}
	return r, nil
}
